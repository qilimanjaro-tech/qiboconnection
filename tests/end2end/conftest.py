# pylint: disable=logging-fstring-interpolation, broad-exception-caught, inconsistent-return-statements
# pylint: disable=protected-access
import logging
import logging.config
import os

import pytest
import qibo
from _pytest.config import Config
from qibo import gates
from qibo.models.circuit import Circuit

from qiboconnection.api import API
from qiboconnection.errors import HTTPError
from qiboconnection.models.devices import Device
from qiboconnection.models.runcard import Runcard
from qiboconnection.typings.vqa import VQA
from tests.end2end.utils.utils import get_api_or_fail_test, get_logging_conf_or_fail_test


def pytest_configure(config: Config):  # pylint: disable=unused-argument
    """Initialize the logging configuration. This is executed once per test session.

    Args:
        config : configuration object
    """
    file_logging_cfg = os.path.join(os.path.dirname(os.path.abspath(__file__)), "logging.ini")

    logging.config.fileConfig(file_logging_cfg, disable_existing_loggers=False)


def pytest_runtest_setup(item):
    """Configure the runtest

    Args:
        item: each of the test functions
    """

    # By default, do not run the tests marked as slow.
    # To run them, we have to use the option --slow when running pytest, to force its execution.
    if "slow" in item.keywords and not item.config.getoption(name="--slow"):
        pytest.skip("need --slow to run this test")


# ------------------------------------------------------------------------------
#  Options
# ------------------------------------------------------------------------------


def pytest_addoption(parser):
    """Add custom  command line options

    Args:
        parser: pytest parser object
    """
    parser.addoption("--slow", action="store_true", help="Run the tests that take long time")


# ------------------------------------------------------------------------------
#  Fixtures
# ------------------------------------------------------------------------------


@pytest.fixture(name="api")
def get_api_fixture() -> API:
    """Gives a usable API instance"""
    return get_api_or_fail_test(logging_conf=get_logging_conf_or_fail_test())


@pytest.fixture(name="devices")
def get_devices(api) -> list[Device]:
    try:
        devices = api.list_devices()
        return devices._devices
    except HTTPError:
        return []


# In pytest, caplog is a built-in fixture that allows you to capture log output
# generated by your code during test execution.
# It stands for "captured log" and provides a convenient way to assert and analyze
# log messages produced by your code.


@pytest.fixture(name="vqa")
@pytest.mark.usefixtures("caplog")
def get_vqa_fixture(caplog) -> VQA:
    """Builds a numpy backend qibo circuit"""
    caplog.set_level("ERROR")

    vqa = VQA(
        vqa_dict={
            "_name": "VQA",
            "ansatz": {
                "_name": "HardwareEfficientAnsatz",
                "_circuit": {"_type": "QuantumCircuit", "_gates": [], "_init_state": None, "n_qubits": 4},
                "n_qubits": 4,
                "layers": 1,
                "connectivity": [(0, 1), (1, 2), (2, 3)],
                "structure": "grouped",
                "one_gate": "U2",
                "two_gate": "CNOT",
            },
            "backend": {"_type": "Qibo", "_circuit": None, "backend": "numpy", "platform": None},
            "cost_function": {
                "_name": "TSP_CostFunction",
                "instance": {
                    "_name": "TSP_Instance",
                    "n_nodes": 2,
                    "start": None,
                    "loop": True,
                    "_distances": [[0.0, 0.5974254293307999], [0.18562253513856275, 0.0]],
                },
                "parameters": [],
                "encoding": "one_hot",
                "lagrange_multiplier": 10,
            },
            "instance": {
                "_name": "TSP_Instance",
                "n_nodes": 2,
                "start": None,
                "loop": True,
                "_distances": [[0.0, 0.5974254293307999], [0.18562253513856275, 0.0]],
            },
            "optimizer": {"_name": "GradientDescent"},
            "sampler": {
                "_name": "Sampler",
                "_circuit": None,
                "_parameters": [],
                "_quantum_state": None,
                "_probability_dict": None,
                "_required_qubits": None,
            },
            "n_shots": 1000,
        },
        init_params=[0 for __name__ in range(18)],
    )

    caplog.clear()
    try:
        return vqa
    except Exception as e:
        pytest.fail(f"Circuit creation failed. {e}.", pytrace=False)


@pytest.fixture(name="numpy_circuit")
@pytest.mark.usefixtures("caplog")
def get_qibo_circuit_numpy_fixture(caplog) -> Circuit:
    """Builds a numpy backend qibo circuit"""
    caplog.set_level("ERROR")

    qibo.set_backend("numpy")  # Must precede circuit definition. Else, execution will fail.
    circuit = Circuit(nqubits=1)
    circuit.add(gates.H(0))
    circuit.add(gates.M(0))

    caplog.clear()
    try:
        return circuit
    except Exception as e:
        pytest.fail(f"Circuit creation failed. {e}.", pytrace=False)


@pytest.fixture(name="one_qubits_500_gates_circuit")
@pytest.mark.usefixtures("caplog")
def one_qubits_500_gates_circuit(caplog) -> Circuit:
    """Build a 500 gates 1 qubit circuit"""
    caplog.set_level("ERROR")

    # init circuit
    c = Circuit(nqubits=1)

    for _ in range(100):
        c.add(gates.Y(0))
        c.add(gates.X(0))
        c.add(gates.I(0))
        c.add(gates.S(0))
        c.add(gates.Z(0))

    # measurement
    c.add(gates.M(0))

    caplog.clear()
    try:
        return c
    except Exception as e:
        pytest.fail(f"Circuit creation failed. {e}.", pytrace=False)


@pytest.fixture(name="two_qubits_500_gates_circuit")
@pytest.mark.usefixtures("caplog")
def two_qubits_500_gates_circuit(caplog) -> Circuit:
    """Build a 500 gates 2 qubit circuit"""
    caplog.set_level("ERROR")

    # init circuit
    c = Circuit(nqubits=2)

    for _ in range(100):
        c.add(gates.Y(0))
        c.add(gates.CNOT(0, 1))
        c.add(gates.I(0))
        c.add(gates.S(1))
        c.add(gates.Z(0))

    # measurement
    c.add(gates.M(0))
    c.add(gates.M(1))

    caplog.clear()
    try:
        return c
    except Exception as e:
        pytest.fail(f"Circuit creation failed. {e}.", pytrace=False)


@pytest.fixture(name="five_qubits_500_gates_circuit")
@pytest.mark.usefixtures("caplog")
def five_qubits_500_gates_circuit(caplog) -> Circuit:
    """Build a 500 gates 5 qubit circuit"""
    caplog.set_level("ERROR")

    # init circuit
    c = Circuit(nqubits=5)

    for _ in range(50):
        c.add(gates.Y(2))
        c.add(gates.X(1))
        c.add(gates.I(0))
        c.add(gates.CNOT(0, 3))
        c.add(gates.Z(0))
        c.add(gates.FSWAP(3, 2))
        c.add(gates.CNOT(1, 4))
        c.add(gates.TOFFOLI(0, 1, 2))
        c.add(gates.TDG(3))
        c.add(gates.CZ(0, 4))

    # measurement
    c.add(gates.M(0))
    c.add(gates.M(1))
    c.add(gates.M(2, 3, 4))

    caplog.clear()
    try:
        return c
    except Exception as e:
        pytest.fail(f"Circuit creation failed. {e}.", pytrace=False)


@pytest.fixture(name="runcard")
def runcard() -> Runcard:
    """Build a simple runcard"""

    return Runcard(
        name="fixture_runcard",
        user_id=3,
        device_id=1,
        description="runcard for testing",
        runcard={"Hello": "world!"},
        qililab_version="bsc-300",
    )


@pytest.fixture(name="results_dict")
def get_results_dict() -> dict:
    """Create a likely qililab results serialization dictionary"""
    return {
        "software_average": 1,
        "num_sequences": 1,
        "shape": [2, 2, 2],
        "loops": [
            {
                "alias": None,
                "instrument": "signal_generator",
                "id_": 0,
                "parameter": "frequency",
                "start": 0,
                "stop": 1,
                "num": 2,
                "step": None,
                "loop": {
                    "alias": "platform",
                    "instrument": None,
                    "id_": None,
                    "parameter": "delay_before_readout",
                    "start": 40,
                    "stop": 100,
                    "num": None,
                    "step": 40,
                    "loop": {
                        "alias": None,
                        "instrument": "awg",
                        "id_": 0,
                        "parameter": "frequency",
                        "start": 0,
                        "stop": 1,
                        "num": 2,
                        "step": None,
                        "loop": None,
                    },
                },
            }
        ],
        "results": [
            {
                "name": "qblox",
                "pulse_length": 2000,
                "bins": [
                    {
                        "integration": {"path0": [-0.08875841551660968], "path1": [-0.4252879595139228]},
                        "threshold": [0.48046875],
                        "avg_cnt": [1024],
                    }
                ],
            },
            {
                "name": "qblox",
                "pulse_length": 2000,
                "bins": [
                    {
                        "integration": {"path0": [-0.08875841551660968], "path1": [-0.4252879595139228]},
                        "threshold": [0.48046875],
                        "avg_cnt": [1024],
                    }
                ],
            },
            {
                "name": "qblox",
                "pulse_length": 2000,
                "bins": [
                    {
                        "integration": {"path0": [-0.08875841551660968], "path1": [-0.4252879595139228]},
                        "threshold": [0.48046875],
                        "avg_cnt": [1024],
                    }
                ],
            },
            {
                "name": "qblox",
                "pulse_length": 2000,
                "bins": [
                    {
                        "integration": {"path0": [-0.08875841551660968], "path1": [-0.4252879595139228]},
                        "threshold": [0.48046875],
                        "avg_cnt": [1024],
                    }
                ],
            },
            {
                "name": "qblox",
                "pulse_length": 2000,
                "bins": [
                    {
                        "integration": {"path0": [-0.08875841551660968], "path1": [-0.4252879595139228]},
                        "threshold": [0.48046875],
                        "avg_cnt": [1024],
                    }
                ],
            },
            {
                "name": "qblox",
                "pulse_length": 2000,
                "bins": [
                    {
                        "integration": {"path0": [-0.08875841551660968], "path1": [-0.4252879595139228]},
                        "threshold": [0.48046875],
                        "avg_cnt": [1024],
                    }
                ],
            },
            {
                "name": "qblox",
                "pulse_length": 2000,
                "bins": [
                    {
                        "integration": {"path0": [-0.08875841551660968], "path1": [-0.4252879595139228]},
                        "threshold": [0.48046875],
                        "avg_cnt": [1024],
                    }
                ],
            },
            {
                "name": "qblox",
                "pulse_length": 2000,
                "bins": [
                    {
                        "integration": {"path0": [-0.08875841551660968], "path1": [-0.4252879595139228]},
                        "threshold": [0.48046875],
                        "avg_cnt": [1024],
                    }
                ],
            },
        ],
    }


@pytest.fixture(name="qprogram_dict")
def get_qprogram_dict() -> dict:
    """Create a likely qililab qprogram serialization dictionary"""
    return {
        "type": "QProgram",
        "attributes": {
            "_body": {
                "type": "Block",
                "attributes": {
                    "_uuid": {"type": "UUID", "uuid": "91424c55-2415-439b-9584-0bf61ddc1e76"},
                    "elements": {"type": "list", "elements": []},
                },
            },
            "_variables": {"type": "list", "elements": []},
            "_block_stack": {
                "type": "deque",
                "elements": [
                    {
                        "type": "Block",
                        "attributes": {
                            "_uuid": {"type": "UUID", "uuid": "91424c55-2415-439b-9584-0bf61ddc1e76"},
                            "elements": {"type": "list", "elements": []},
                        },
                    }
                ],
            },
        },
    }
